/*
 * Copyright (C) 2023 Hal Hildebrand. All rights reserved.
 * 
 * This file is part of the Prime Mover Event Driven Simulation Framework.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.primeMover.asm;

import java.io.IOException;
import java.lang.classfile.*;
import java.lang.classfile.attribute.*;
import java.lang.classfile.instruction.*;
import java.lang.constant.*;
import java.net.MalformedURLException;
import java.time.Instant;
import java.util.*;

import com.hellblazer.primeMover.Kronos;
import com.hellblazer.primeMover.annotations.Blocking;
import com.hellblazer.primeMover.asm.OpenAddressingSet.OpenSet;
import com.hellblazer.primeMover.runtime.Kairos;

import io.github.classgraph.ClassInfo;
import io.github.classgraph.MethodInfo;
import io.github.classgraph.MethodParameterInfo;

/**
 * Transforms Entity classes into PrimeMover entities using the Java 24 ClassFile API (JEP 484).
 * 
 * This class generates the same bytecode as EntityGeneratorRefactored but uses the modern
 * ClassFile API instead of ASM for bytecode manipulation. The generated bytecode is
 * byte-for-byte identical to ensure compatibility.
 * 
 * Key responsibilities:
 * - Transform method calls into simulation events
 * - Generate EntityReference implementation methods (__invoke, __signatureFor)
 * - Handle method remapping for event processing
 * - Manage primitive type boxing/unboxing for event parameters
 *
 * @author hal.hildebrand
 */
public class EntityGenerator {

    // === Method Names ===
    private static final String INVOKE = "__invoke";
    private static final String SIGNATURE_FOR = "__signatureFor";
    
    // === Templates ===
    private static final String METHOD_REMAP_KEY_TEMPLATE = "%s.%s%s";
    private static final String REMAPPED_TEMPLATE = "%s$event";
    
    // === ClassFile API Constants ===
    private static final ClassDesc OBJECT_CLASS = ConstantDescs.CD_Object;
    private static final ClassDesc STRING_CLASS = ConstantDescs.CD_String;
    private static final ClassDesc OBJECT_ARRAY_CLASS = ClassDesc.of("java.lang.Object").arrayType();
    private static final ClassDesc ENTITY_REFERENCE_CLASS = ClassDesc.of("com.hellblazer.primeMover.runtime.EntityReference");
    private static final ClassDesc FRAMEWORK_CLASS = ClassDesc.of("com.hellblazer.primeMover.runtime.Framework");
    private static final ClassDesc DEVI_CLASS = ClassDesc.of("com.hellblazer.primeMover.runtime.Devi");
    private static final ClassDesc TRANSFORMED_CLASS = ClassDesc.of("com.hellblazer.primeMover.annotations.Transformed");
    
    // === Method Type Descriptors ===
    private static final MethodTypeDesc INVOKE_METHOD_TYPE = MethodTypeDesc.of(OBJECT_CLASS, ConstantDescs.CD_int, OBJECT_ARRAY_CLASS);
    private static final MethodTypeDesc SIGNATURE_FOR_METHOD_TYPE = MethodTypeDesc.of(STRING_CLASS, ConstantDescs.CD_int);
    private static final MethodTypeDesc GET_CONTROLLER_METHOD_TYPE = MethodTypeDesc.of(DEVI_CLASS);
    private static final MethodTypeDesc POST_EVENT_METHOD_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ENTITY_REFERENCE_CLASS, ConstantDescs.CD_int, OBJECT_ARRAY_CLASS);
    private static final MethodTypeDesc POST_CONTINUING_EVENT_METHOD_TYPE = MethodTypeDesc.of(OBJECT_CLASS, ENTITY_REFERENCE_CLASS, ConstantDescs.CD_int, OBJECT_ARRAY_CLASS);
    
    // === Instance State ===
    private final ClassInfo clazz;
    private final String className;
    private final ClassDesc classDesc;
    private final String timestamp;
    
    // Event Processing State
    private final Set<MethodInfo> allEventMethods;
    private final Set<MethodInfo> blockingMethods;
    private final Set<MethodInfo> remappedMethods;
    private final Map<Integer, MethodInfo> indexToMethod;
    private final Map<MethodInfo, Integer> methodToIndex;

    /**
     * Creates a new EntityGenerator for the specified class and events.
     * 
     * @param clazz The class to transform
     * @param events The set of methods to transform into events
     */
    public EntityGenerator(ClassInfo clazz, Set<MethodInfo> events) {
        this(clazz, events, Instant.now().toString());
    }
    
    /**
     * Creates a new EntityGenerator for the specified class and events with a specific timestamp.
     * 
     * @param clazz The class to transform
     * @param events The set of methods to transform into events
     * @param timestamp The timestamp to use in the @Transformed annotation
     */
    public EntityGenerator(ClassInfo clazz, Set<MethodInfo> events, String timestamp) {
        this.clazz = clazz;
        this.className = clazz.getName();
        this.classDesc = ClassDesc.of(className);
        this.timestamp = timestamp;
        
        // Initialize collections
        this.indexToMethod = new HashMap<>();
        this.methodToIndex = new HashMap<>();
        this.remappedMethods = new OpenSet<>();
        this.blockingMethods = new OpenSet<>();
        this.allEventMethods = new OpenSet<>();
        this.allEventMethods.addAll(events);
        
        initializeEventMappings(events);
    }

    /**
     * Initialize event mappings and determine which methods are blocking/remapped
     */
    private void initializeEventMappings(Set<MethodInfo> eventMethods) {
        var key = 0;
        for (var mi : eventMethods.stream().sorted().toList()) {
            indexToMethod.put(key, mi);
            methodToIndex.put(mi, key++);
            
            // Determine if this is a blocking event
            if (isBlockingEvent(mi)) {
                blockingMethods.add(mi);
            }
            
            // Determine if this method should be remapped
            if (isDeclaredInClass(mi)) {
                remappedMethods.add(mi);
            }
        }
    }
    
    private boolean isBlockingEvent(MethodInfo mi) {
        return !mi.getTypeDescriptor().getResultType().toString().equals("void") 
            || mi.hasAnnotation(Blocking.class);
    }
    
    private boolean isDeclaredInClass(MethodInfo mi) {
        return clazz.getDeclaredMethodInfo(mi.getName())
                   .stream()
                   .anyMatch(m -> mi.equals(m));
    }

    /**
     * Generates the transformed bytecode for the entity class using ClassFile API.
     * 
     * @return byte array containing the generated bytecode
     * @throws MalformedURLException if the class resource URL is malformed
     * @throws IOException if there's an error reading the class resource
     */
    public byte[] generate() throws MalformedURLException, IOException {
        ClassFile cf = ClassFile.of();
        
        try (var is = clazz.getResource().open()) {
            byte[] originalBytes = is.readAllBytes();
            ClassModel originalClass = cf.parse(originalBytes);
            
            // Rebuild the class completely with correct method ordering
            return cf.build(originalClass.thisClass().asSymbol(), classBuilder -> {
                // Copy class-level attributes but build methods in correct order
                buildTransformedClass(classBuilder, originalClass);
            });
        }
    }
    
    /**
     * Build the transformed class with correct method ordering
     */
    private void buildTransformedClass(ClassBuilder classBuilder, ClassModel originalClass) {
        // Set basic class info
        classBuilder.withFlags(originalClass.flags().flagsMask());
        
        if (originalClass.superclass().isPresent()) {
            classBuilder.withSuperclass(originalClass.superclass().get().asSymbol());
        }
        
        // Copy non-method elements from original class (we'll set interfaces manually)
        for (ClassElement element : originalClass) {
            if (!(element instanceof MethodModel)) {
                // Skip interface-related attributes - we'll set them manually
                String elementName = element.getClass().getSimpleName();
                if (!elementName.contains("Interface")) {
                    classBuilder.with(element);
                }
            }
        }
        
        // Set interfaces (original + EntityReference) - do this after copying other elements
        var originalInterfaces = clazz.getInterfaces()
                                     .stream()
                                     .map(ci -> ClassDesc.of(ci.getName()))
                                     .toArray(ClassDesc[]::new);
        
        var allInterfaces = new ClassDesc[originalInterfaces.length + 1];
        System.arraycopy(originalInterfaces, 0, allInterfaces, 0, originalInterfaces.length);
        allInterfaces[originalInterfaces.length] = ENTITY_REFERENCE_CLASS;
        
        classBuilder.withInterfaceSymbols(allInterfaces);
        
        // Add @Transformed annotation
        classBuilder.with(RuntimeVisibleAnnotationsAttribute.of(
            Annotation.of(TRANSFORMED_CLASS,
                AnnotationElement.of("timestamp", AnnotationValue.ofString(timestamp))
            )
        ));
        
        // Generate methods in correct order to match ASM implementation:
        
        // 1. Copy constructors first  
        for (MethodModel methodModel : originalClass.methods()) {
            if (methodModel.methodName().stringValue().equals("<init>")) {
                classBuilder.with(methodModel);
            }
        }
        
        // 2. Generate event wrapper methods and their corresponding $event methods in pairs
        for (MethodModel methodModel : originalClass.methods()) {
            String methodName = methodModel.methodName().stringValue();
            if (!methodName.equals("<init>")) {
                MethodInfo methodInfo = findMethodInfo(methodModel);
                if (methodInfo != null && remappedMethods.contains(methodInfo)) {
                    // First generate the event wrapper (with original name)
                    generateEventWrapperMethod(classBuilder, methodInfo, methodModel);
                    
                    // Then generate the original method with $event suffix
                    String eventMethodName = REMAPPED_TEMPLATE.formatted(methodName);
                    
                    // Match ASM implementations: hardcode access flags to PROTECTED for $event methods
                    int eventMethodFlags = 0x0004; // ACC_PROTECTED = 4
                    
                    classBuilder.withMethod(eventMethodName,
                        methodModel.methodTypeSymbol(),
                        eventMethodFlags,
                        methodBuilder -> {
                            // Apply API remapping transformation to copy method elements
                            ClassRemapper apiRemapper = new ClassRemapper(classDesc -> {
                                String className = classDesc.packageName() + "." + classDesc.displayName();
                                if (className.equals(Kronos.class.getCanonicalName())) {
                                    return ClassDesc.of(Kairos.class.getCanonicalName());
                                }
                                return classDesc;
                            });
                            
                            // Use MethodTransform to copy elements but preserve access flags
                            MethodTransform methodTransform = (mb, me) -> {
                                if (!(me instanceof AccessFlags)) {
                                    apiRemapper.asMethodTransform().accept(mb, me);
                                }
                                // Skip AccessFlags - already set by withMethod
                            };
                            
                            methodBuilder.transform(methodModel, methodTransform);
                        });
                }
            }
        }
        
        // 3. Copy remaining non-event methods (except constructors already copied)
        for (MethodModel methodModel : originalClass.methods()) {
            String methodName = methodModel.methodName().stringValue();
            if (!methodName.equals("<init>")) {
                MethodInfo methodInfo = findMethodInfo(methodModel);
                if (methodInfo == null || !remappedMethods.contains(methodInfo)) {
                    // Regular method, copy as-is
                    classBuilder.with(methodModel);
                }
            }
        }
        
        // 5. Generate EntityReference methods (always generate for ASM compatibility)
        generateInvokeMethod(classBuilder);
        generateSignatureForMethod(classBuilder);
    }
    
    /**
     * Find MethodInfo that matches a MethodModel
     */
    private MethodInfo findMethodInfo(MethodModel methodModel) {
        String name = methodModel.methodName().stringValue();
        String descriptor = methodModel.methodTypeSymbol().descriptorString();
        
        return allEventMethods.stream()
            .filter(mi -> mi.getName().equals(name) && mi.getTypeDescriptorStr().equals(descriptor))
            .findFirst()
            .orElse(null);
    }

    /**
     * Checks if the original class already has an __invoke method.
     * 
     * @param originalClass The original class model
     * @return true if __invoke method exists
     */
    private boolean hasInvokeMethod(ClassModel originalClass) {
        return originalClass.methods().stream()
            .anyMatch(method -> method.methodName().stringValue().equals("__invoke"));
    }

    /**
     * Checks if the original class already has a __signatureFor method.
     * 
     * @param originalClass The original class model
     * @return true if __signatureFor method exists
     */
    private boolean hasSignatureForMethod(ClassModel originalClass) {
        return originalClass.methods().stream()
            .anyMatch(method -> method.methodName().stringValue().equals("__signatureFor"));
    }

    
    /**
     * Generate an event wrapper method with the original method name
     */
    private void generateEventWrapperMethod(ClassBuilder classBuilder, MethodInfo originalMethod, MethodModel methodModel) {
        // Use the original method name for the event wrapper
        String wrapperMethodName = originalMethod.getName();
        
        // Get access flags from the MethodModel to match ClassFile API format
        int accessFlags = methodModel.flags().flagsMask();
        
        classBuilder.withMethodBody(wrapperMethodName,
            MethodTypeDesc.ofDescriptor(originalMethod.getTypeDescriptorStr()),
            accessFlags,
            codeBuilder -> {
                // Get method index
                Integer methodIndex = methodToIndex.get(originalMethod);
                if (methodIndex == null) {
                    throw new IllegalStateException("No index found for method: " + originalMethod);
                }
                
                // Call Framework.getController()
                codeBuilder.invokestatic(FRAMEWORK_CLASS, "getController", GET_CONTROLLER_METHOD_TYPE);
                
                // Load 'this' for posting the event
                codeBuilder.aload(0);
                
                // Load method index
                codeBuilder.ldc(methodIndex);
                
                // Create and populate arguments array
                int paramCount = originalMethod.getParameterInfo().length;
                codeBuilder.ldc(paramCount);
                codeBuilder.anewarray(OBJECT_CLASS);
                
                // Store each parameter in the array
                var paramTypes = originalMethod.getParameterInfo();
                for (int i = 0; i < paramTypes.length; i++) {
                    codeBuilder.dup();
                    codeBuilder.ldc(i);
                    loadParameter(codeBuilder, i + 1, paramTypes[i]);
                    boxPrimitiveIfNeeded(codeBuilder, paramTypes[i]);
                    codeBuilder.aastore();
                }
                
                // Determine which post method to call based on blocking status
                if (blockingMethods.contains(originalMethod)) {
                    codeBuilder.invokevirtual(DEVI_CLASS, "postContinuingEvent", POST_CONTINUING_EVENT_METHOD_TYPE);
                    // postContinuingEvent returns Object, so pop it off the stack
                    codeBuilder.pop();
                } else {
                    codeBuilder.invokevirtual(DEVI_CLASS, "postEvent", POST_EVENT_METHOD_TYPE);
                    // postEvent returns void, so nothing to pop
                }
                
                // Return appropriate value
                returnDefaultValue(codeBuilder, originalMethod);
            });
    }
    
    /**
     * Load a parameter onto the stack with the correct load instruction
     */
    private void loadParameter(CodeBuilder codeBuilder, int index, MethodParameterInfo param) {
        var typeDescriptor = param.getTypeDescriptor();
        
        if (typeDescriptor instanceof io.github.classgraph.BaseTypeSignature bts) {
            // Load primitive types with appropriate instruction
            loadPrimitive(codeBuilder, index, bts.getTypeSignatureChar());
        } else {
            // Load reference types (objects, arrays, etc.)
            codeBuilder.aload(index);
        }
    }
    
    /**
     * Load a primitive type with the correct instruction
     */
    private void loadPrimitive(CodeBuilder codeBuilder, int index, char primitiveType) {
        switch (primitiveType) {
            case 'I', 'B', 'C', 'S', 'Z' -> codeBuilder.iload(index);
            case 'J' -> codeBuilder.lload(index);
            case 'F' -> codeBuilder.fload(index);
            case 'D' -> codeBuilder.dload(index);
            default -> throw new IllegalArgumentException("Unknown primitive type: " + primitiveType);
        }
    }
    
    /**
     * Box primitive types for storage in Object array
     */
    private void boxPrimitiveIfNeeded(CodeBuilder codeBuilder, MethodParameterInfo param) {
        var typeDescriptor = param.getTypeDescriptor();
        
        if (typeDescriptor instanceof io.github.classgraph.BaseTypeSignature bts) {
            // Box primitive types
            boxPrimitive(codeBuilder, bts.getTypeSignatureChar());
        }
        // Reference types don't need boxing - they're already objects
    }
    
    /**
     * Box a primitive type to its wrapper object
     */
    private void boxPrimitive(CodeBuilder codeBuilder, char primitiveType) {
        switch (primitiveType) {
            case 'I' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Integer"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Integer"), ConstantDescs.CD_int));
            case 'J' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Long"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Long"), ConstantDescs.CD_long));
            case 'F' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Float"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Float"), ConstantDescs.CD_float));
            case 'D' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Double"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Double"), ConstantDescs.CD_double));
            case 'Z' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Boolean"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Boolean"), ConstantDescs.CD_boolean));
            case 'B' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Byte"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Byte"), ConstantDescs.CD_byte));
            case 'C' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Character"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Character"), ConstantDescs.CD_char));
            case 'S' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Short"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Short"), ConstantDescs.CD_short));
            default -> throw new IllegalArgumentException("Unknown primitive type: " + primitiveType);
        }
    }
    
    /**
     * Return the appropriate default value based on method return type
     */
    private void returnDefaultValue(CodeBuilder codeBuilder, MethodInfo method) {
        var returnTypeDescriptor = method.getTypeDescriptor().getResultType();
        
        // Use the same approach as ASM implementation for void check
        if (returnTypeDescriptor.toStringWithSimpleNames().equals("void")) {
            codeBuilder.return_();
            return;
        }
        
        if (returnTypeDescriptor instanceof io.github.classgraph.BaseTypeSignature bts) {
            // Return default values for primitive types
            returnPrimitiveDefault(codeBuilder, bts.getTypeSignatureChar());
        } else {
            // Return null for reference types
            codeBuilder.aconst_null();
            codeBuilder.areturn();
        }
    }
    
    /**
     * Return the default value for a primitive type
     */
    private void returnPrimitiveDefault(CodeBuilder codeBuilder, char primitiveType) {
        switch (primitiveType) {
            case 'I', 'B', 'C', 'S', 'Z' -> {
                codeBuilder.iconst_0();
                codeBuilder.ireturn();
            }
            case 'J' -> {
                codeBuilder.lconst_0();
                codeBuilder.lreturn();
            }
            case 'F' -> {
                codeBuilder.fconst_0();
                codeBuilder.freturn();
            }
            case 'D' -> {
                codeBuilder.dconst_0();
                codeBuilder.dreturn();
            }
            default -> throw new IllegalArgumentException("Unknown primitive type: " + primitiveType);
        }
    }
    
    
    /**
     * Generate the __invoke method for EntityReference interface using ClassFile API
     */
    private void generateInvokeMethod(ClassBuilder classBuilder) {
        if (indexToMethod.isEmpty()) {
            return;
        }
        
        classBuilder.withMethodBody(INVOKE, INVOKE_METHOD_TYPE, ClassFile.ACC_PUBLIC,
            codeBuilder -> {
                // Create switch table for event dispatching
                int[] keys = indexToMethod.keySet().stream().mapToInt(Integer::intValue).sorted().toArray();
                
                codeBuilder.iload(1); // Load event index parameter
                
                // Use tableswitch for efficient dispatch
                Label defaultLabel = codeBuilder.newLabel();
                java.util.List<SwitchCase> cases = new java.util.ArrayList<>();
                
                // Create labels and cases for each method
                for (int key : keys) {
                    Label caseLabel = codeBuilder.newLabel();
                    cases.add(SwitchCase.of(key, caseLabel));
                }
                
                codeBuilder.tableswitch(keys[0], keys[keys.length - 1], defaultLabel, cases);
                
                // Generate each case
                for (int i = 0; i < keys.length; i++) {
                    int key = keys[i];
                    Label caseLabel = cases.get(i).target();
                    codeBuilder.labelBinding(caseLabel);
                    generateInvokeCase(codeBuilder, key);
                }
                
                // Generate default case
                codeBuilder.labelBinding(defaultLabel);
                codeBuilder
                    .new_(ClassDesc.of("java.lang.IllegalStateException"))
                    .dup()
                    .ldc("Unknown event type")
                    .invokespecial(ClassDesc.of("java.lang.IllegalStateException"), 
                        "<init>", MethodTypeDesc.of(ConstantDescs.CD_void, STRING_CLASS))
                    .athrow();
            });
    }
    
    /**
     * Generate a single case in the __invoke switch statement
     */
    private void generateInvokeCase(CodeBuilder codeBuilder, int methodIndex) {
        MethodInfo methodInfo = indexToMethod.get(methodIndex);
        if (methodInfo == null) {
            throw new IllegalArgumentException("No method found for index: " + methodIndex);
        }
        
        // Load 'this'
        codeBuilder.aload(0);
        
        // Load and unbox parameters from Object array
        var paramTypes = methodInfo.getParameterInfo();
        for (int i = 0; i < paramTypes.length; i++) {
            codeBuilder.aload(2); // Load args array
            codeBuilder.ldc(i);   // Load index
            codeBuilder.aaload(); // Get args[i]
            unboxParameter(codeBuilder, paramTypes[i]);
        }
        
        // Call the appropriate method
        String methodName = REMAPPED_TEMPLATE.formatted(methodInfo.getName());
        if (remappedMethods.contains(methodInfo)) {
            // Call the event wrapper method on this class
            codeBuilder.invokevirtual(classDesc, methodName, 
                MethodTypeDesc.ofDescriptor(methodInfo.getTypeDescriptorStr()));
        } else {
            // Call the method on superclass
            var superClass = clazz.getSuperclass();
            if (superClass != null) {
                codeBuilder.invokespecial(ClassDesc.of(superClass.getName()), methodName,
                    MethodTypeDesc.ofDescriptor(methodInfo.getTypeDescriptorStr()));
            }
        }
        
        // Handle return value
        String returnType = methodInfo.getTypeDescriptor().getResultType().toString();
        if (returnType.equals("void")) {
            codeBuilder.aload(0); // Return 'this' for void methods
        } else {
            boxReturnValue(codeBuilder, returnType);
        }
        codeBuilder.areturn();
    }
    
    /**
     * Convert a parameter from Object to the target type (primitive or reference)
     */
    private void unboxParameter(CodeBuilder codeBuilder, MethodParameterInfo param) {
        var typeDescriptor = param.getTypeDescriptor();
        
        if (typeDescriptor instanceof io.github.classgraph.BaseTypeSignature bts) {
            // Handle primitive types - unbox from wrapper objects
            unboxPrimitive(codeBuilder, bts.getTypeSignatureChar());
        } else if (typeDescriptor instanceof io.github.classgraph.ArrayTypeSignature ats) {
            // Handle array types - cast to specific array type
            String arrayType = ats.toString();
            codeBuilder.checkcast(ClassDesc.ofDescriptor(ats.getTypeSignatureStr()));
        } else {
            // Handle reference types (Objects, wrappers when used as Objects)
            String className = typeDescriptor.toString();
            
            // Special handling for wrapper classes that might need to stay as wrapper objects
            if (isWrapperClass(className)) {
                codeBuilder.checkcast(ClassDesc.of(className));
            } else if (className.startsWith("java.lang.") || className.equals("java.lang.String")) {
                codeBuilder.checkcast(ClassDesc.of(className));
            } else {
                // Custom reference types
                codeBuilder.checkcast(ClassDesc.of(className));
            }
        }
    }
    
    /**
     * Unbox a primitive type from its wrapper object
     */
    private void unboxPrimitive(CodeBuilder codeBuilder, char primitiveType) {
        switch (primitiveType) {
            case 'I' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Integer"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Integer"), "intValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_int));
            }
            case 'J' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Long"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Long"), "longValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_long));
            }
            case 'F' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Float"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Float"), "floatValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_float));
            }
            case 'D' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Double"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Double"), "doubleValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_double));
            }
            case 'Z' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Boolean"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Boolean"), "booleanValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_boolean));
            }
            case 'B' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Byte"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Byte"), "byteValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_byte));
            }
            case 'C' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Character"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Character"), "charValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_char));
            }
            case 'S' -> {
                codeBuilder.checkcast(ClassDesc.of("java.lang.Short"));
                codeBuilder.invokevirtual(ClassDesc.of("java.lang.Short"), "shortValue", 
                    MethodTypeDesc.of(ConstantDescs.CD_short));
            }
            default -> throw new IllegalArgumentException("Unknown primitive type: " + primitiveType);
        }
    }
    
    /**
     * Check if a class name represents a wrapper class
     */
    private boolean isWrapperClass(String className) {
        return className.equals("java.lang.Integer") ||
               className.equals("java.lang.Long") ||
               className.equals("java.lang.Float") ||
               className.equals("java.lang.Double") ||
               className.equals("java.lang.Boolean") ||
               className.equals("java.lang.Byte") ||
               className.equals("java.lang.Character") ||
               className.equals("java.lang.Short");
    }
    
    /**
     * Box a return value for Object return type
     */
    private void boxReturnValue(CodeBuilder codeBuilder, String returnType) {
        switch (returnType.charAt(0)) {
            case 'I' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Integer"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Integer"), ConstantDescs.CD_int));
            case 'J' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Long"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Long"), ConstantDescs.CD_long));
            case 'F' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Float"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Float"), ConstantDescs.CD_float));
            case 'D' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Double"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Double"), ConstantDescs.CD_double));
            case 'Z' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Boolean"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Boolean"), ConstantDescs.CD_boolean));
            case 'B' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Byte"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Byte"), ConstantDescs.CD_byte));
            case 'C' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Character"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Character"), ConstantDescs.CD_char));
            case 'S' -> codeBuilder.invokestatic(ClassDesc.of("java.lang.Short"), 
                "valueOf", MethodTypeDesc.of(ClassDesc.of("java.lang.Short"), ConstantDescs.CD_short));
            // Reference types are already Objects
        }
    }
    
    /**
     * Generate the __signatureFor method for EntityReference interface using ClassFile API
     */
    private void generateSignatureForMethod(ClassBuilder classBuilder) {
        if (indexToMethod.isEmpty()) {
            return;
        }
        
        classBuilder.withMethodBody(SIGNATURE_FOR, SIGNATURE_FOR_METHOD_TYPE, ClassFile.ACC_PUBLIC,
            codeBuilder -> {
                // Create switch table for signature lookup
                int[] keys = indexToMethod.keySet().stream().mapToInt(Integer::intValue).sorted().toArray();
                
                codeBuilder.iload(1); // Load method index parameter
                
                // Use tableswitch for efficient dispatch
                Label defaultLabel = codeBuilder.newLabel();
                java.util.List<SwitchCase> cases = new java.util.ArrayList<>();
                
                // Create labels and cases for each method
                for (int key : keys) {
                    Label caseLabel = codeBuilder.newLabel();
                    cases.add(SwitchCase.of(key, caseLabel));
                }
                
                codeBuilder.tableswitch(keys[0], keys[keys.length - 1], defaultLabel, cases);
                
                // Generate each case
                for (int i = 0; i < keys.length; i++) {
                    int key = keys[i];
                    Label caseLabel = cases.get(i).target();
                    codeBuilder.labelBinding(caseLabel);
                    generateSignatureCase(codeBuilder, key);
                }
                
                // Generate default case
                codeBuilder.labelBinding(defaultLabel);
                codeBuilder
                    .new_(ClassDesc.of("java.lang.IllegalArgumentException"))
                    .dup()
                    .ldc("Unknown event")
                    .invokespecial(ClassDesc.of("java.lang.IllegalArgumentException"), 
                        "<init>", MethodTypeDesc.of(ConstantDescs.CD_void, STRING_CLASS))
                    .athrow();
            });
    }
    
    /**
     * Generate a single case in the __signatureFor switch statement
     */
    private void generateSignatureCase(CodeBuilder codeBuilder, int methodIndex) {
        MethodInfo methodInfo = indexToMethod.get(methodIndex);
        if (methodInfo == null) {
            codeBuilder.ldc("");
        } else {
            String signature = buildMethodSignature(methodInfo);
            codeBuilder.ldc(signature);
        }
        codeBuilder.areturn();
    }
    
    /**
     * Build a human-readable method signature string
     */
    private String buildMethodSignature(MethodInfo methodInfo) {
        var signature = new StringBuilder();
        signature.append('<')
                 .append(className)
                 .append(": ")
                 .append(methodInfo.getTypeDescriptor().getResultType())
                 .append(" ")
                 .append(methodInfo.getName())
                 .append('(');
        
        boolean first = true;
        for (var param : methodInfo.getParameterInfo()) {
            if (!first) signature.append(", ");
            signature.append(param.getTypeDescriptor());
            first = false;
        }
        
        signature.append(")>");
        return signature.toString();
    }
    
}
