/*
 * Copyright (C) 2026 Hal Hildebrand. All rights reserved.
 *
 * This file is part of the Prime Mover Event Driven Simulation Framework.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.primeMover.classfile;

import com.hellblazer.primeMover.api.EntityReference;
import org.junit.jupiter.api.Test;

import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests that method ordinals are stable across multiple instantiations of EntityGenerator.
 * This is critical for semantic versioning - ordinals must be deterministic and consistent.
 *
 * @author hal.hildebrand
 */
public class MethodOrdinalStabilityTest {

    /**
     * Test that method ordinals are stable across multiple EntityGenerator instantiations.
     * This verifies that the same class transformed multiple times always produces the same
     * ordinal-to-method mapping.
     */
    @Test
    public void testOrdinalStabilityAcrossMultipleGenerations() throws Exception {
        var scanner = new ClassScanner()
            .addClasspathEntry(Path.of("target/test-classes"))
            .addClasspathEntry(Path.of("target/classes"))
            .scan();

        final var className = "com.hellblazer.primeMover.classfile.testClasses.MyTest";
        final int iterations = 20; // Generate 20 times to catch non-determinism

        List<Map<Integer, String>> ordinalMappings = new ArrayList<>();

        // Generate the class multiple times and extract ordinal mappings
        for (int i = 0; i < iterations; i++) {
            var transform = new SimulationTransform(scanner);
            var generator = transform.generatorOf(className);
            assertNotNull(generator, "Generator should not be null for iteration " + i);

            byte[] bytes = generator.generate();
            assertNotNull(bytes, "Generated bytes should not be null for iteration " + i);

            // Load the generated class
            final int iteration = i;
            var loader = new ClassLoader(getClass().getClassLoader()) {
                {
                    defineClass(className, ByteBuffer.wrap(bytes), null);
                }
            };
            var clazz = loader.loadClass(className);
            assertNotNull(clazz, "Loaded class should not be null for iteration " + iteration);

            // Extract ordinal-to-signature mapping using __signatureFor
            var instance = clazz.getConstructor().newInstance();
            assertTrue(instance instanceof EntityReference,
                       "Instance should implement EntityReference for iteration " + iteration);

            var entityRef = (EntityReference) instance;
            var mapping = extractOrdinalMapping(entityRef);

            ordinalMappings.add(mapping);
        }

        // Verify all mappings are identical
        var firstMapping = ordinalMappings.get(0);
        assertFalse(firstMapping.isEmpty(), "First mapping should not be empty");

        for (int i = 1; i < ordinalMappings.size(); i++) {
            var currentMapping = ordinalMappings.get(i);
            assertEquals(firstMapping.size(), currentMapping.size(),
                        "Mapping size should be consistent across iterations (iteration " + i + ")");

            for (var entry : firstMapping.entrySet()) {
                var ordinal = entry.getKey();
                var expectedSignature = entry.getValue();
                var actualSignature = currentMapping.get(ordinal);

                assertEquals(expectedSignature, actualSignature,
                            "Ordinal " + ordinal + " should map to the same method signature " +
                            "across all iterations (iteration " + i + ")");
            }
        }

        // Verify expected methods are present (ordinals are now hash-based, not sequential)
        // Ordinals should be stable but non-sequential
        var ordinals = new ArrayList<>(firstMapping.keySet());
        ordinals.sort(Integer::compareTo);
        assertEquals(3, ordinals.size(), "MyTest should have exactly 3 event methods");

        // Verify all methods are present somewhere in the mapping
        boolean hasBar = firstMapping.values().stream().anyMatch(sig -> sig.contains("bar()"));
        boolean hasMyMy = firstMapping.values().stream().anyMatch(sig -> sig.contains("myMy"));
        boolean hasSomeArgs = firstMapping.values().stream().anyMatch(sig -> sig.contains("someArgs"));

        assertTrue(hasBar, "bar() method should be present in ordinal mapping");
        assertTrue(hasMyMy, "myMy() method should be present in ordinal mapping");
        assertTrue(hasSomeArgs, "someArgs() method should be present in ordinal mapping");
    }

    /**
     * Extract ordinal-to-signature mapping from an EntityReference instance.
     * Queries __signatureFor for ordinals 0..99 until we get null responses.
     */
    private Map<Integer, String> extractOrdinalMapping(EntityReference entityRef) {
        var mapping = new HashMap<Integer, String>();

        // Query ordinals until we get nulls (indicating no more methods)
        for (int ordinal = 0; ordinal < 100; ordinal++) {
            try {
                var signature = entityRef.__signatureFor(ordinal);
                if (signature == null || signature.isEmpty()) {
                    break;
                }
                mapping.put(ordinal, signature);
            } catch (Exception e) {
                // Stop when we hit an unknown ordinal
                break;
            }
        }

        return mapping;
    }

    /**
     * Test that hash-based ordinals are deterministic for the same method signature.
     * This verifies that the hash function produces stable ordinals across multiple invocations.
     */
    @Test
    public void testHashBasedOrdinalsDeterministic() {
        // Test that the same signature always produces the same ordinal
        var signature1 = "bar()V";
        var signature2 = "bar()V";
        var signature3 = "myMy()Ljava/lang/String;";

        var hash1 = signature1.hashCode() & 0x7FFFFFFF;
        var hash2 = signature2.hashCode() & 0x7FFFFFFF;
        var hash3 = signature3.hashCode() & 0x7FFFFFFF;

        assertEquals(hash1, hash2, "Identical signatures should produce identical hashes");
        assertNotEquals(hash1, hash3, "Different signatures should produce different hashes");

        // Verify hash values are positive (masked to remove sign bit)
        assertTrue(hash1 >= 0, "Hash should be positive");
        assertTrue(hash3 >= 0, "Hash should be positive");
    }

    /**
     * Test that ordinals remain stable when the same generator instance is used multiple times.
     * This is a simpler test that verifies consistency within a single EntityGenerator instance.
     */
    @Test
    public void testOrdinalStabilityWithinSingleGenerator() throws Exception {
        var scanner = new ClassScanner()
            .addClasspathEntry(Path.of("target/test-classes"))
            .addClasspathEntry(Path.of("target/classes"))
            .scan();

        final var className = "com.hellblazer.primeMover.classfile.testClasses.MyTest";
        var transform = new SimulationTransform(scanner);
        var generator = transform.generatorOf(className);
        assertNotNull(generator);

        // Generate the same class multiple times from the same generator
        List<Map<Integer, String>> mappings = new ArrayList<>();

        for (int i = 0; i < 5; i++) {
            byte[] bytes = generator.generate();
            final int iteration = i;
            var loader = new ClassLoader(getClass().getClassLoader()) {
                {
                    defineClass(className, ByteBuffer.wrap(bytes), null);
                }
            };
            var clazz = loader.loadClass(className);
            var instance = clazz.getConstructor().newInstance();
            var entityRef = (EntityReference) instance;
            mappings.add(extractOrdinalMapping(entityRef));
        }

        // All mappings should be identical
        var firstMapping = mappings.get(0);
        for (int i = 1; i < mappings.size(); i++) {
            assertEquals(firstMapping, mappings.get(i),
                        "Mapping should be consistent across multiple generate() calls (iteration " + i + ")");
        }
    }
}
