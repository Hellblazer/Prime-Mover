/*
 * Copyright (C) 2026 Hal Hildebrand. All rights reserved.
 *
 * This file is part of the Prime Mover Event Driven Simulation Framework.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hellblazer.primeMover.classfile;

import com.hellblazer.primeMover.api.EntityReference;
import org.junit.jupiter.api.Test;

import java.nio.ByteBuffer;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests that method ordinals are stable across multiple instantiations of EntityGenerator.
 * This is critical for semantic versioning - ordinals must be deterministic and consistent.
 *
 * @author hal.hildebrand
 */
public class MethodOrdinalStabilityTest {

    /**
     * Test that method ordinals are stable across multiple EntityGenerator instantiations.
     * This verifies that the same class transformed multiple times always produces the same
     * ordinal-to-method mapping.
     */
    @Test
    public void testOrdinalStabilityAcrossMultipleGenerations() throws Exception {
        var scanner = new ClassScanner()
            .addClasspathEntry(Path.of("target/test-classes"))
            .addClasspathEntry(Path.of("target/classes"))
            .scan();

        final var className = "com.hellblazer.primeMover.classfile.testClasses.MyTest";
        final int iterations = 20; // Generate 20 times to catch non-determinism

        List<Map<Integer, String>> ordinalMappings = new ArrayList<>();

        // Generate the class multiple times and extract ordinal mappings
        for (int i = 0; i < iterations; i++) {
            var transform = new SimulationTransform(scanner);
            var generator = transform.generatorOf(className);
            assertNotNull(generator, "Generator should not be null for iteration " + i);

            byte[] bytes = generator.generate();
            assertNotNull(bytes, "Generated bytes should not be null for iteration " + i);

            // Load the generated class
            final int iteration = i;
            var loader = new ClassLoader(getClass().getClassLoader()) {
                {
                    defineClass(className, ByteBuffer.wrap(bytes), null);
                }
            };
            var clazz = loader.loadClass(className);
            assertNotNull(clazz, "Loaded class should not be null for iteration " + iteration);

            // Extract ordinal-to-signature mapping using __signatureFor
            var instance = clazz.getConstructor().newInstance();
            assertTrue(instance instanceof EntityReference,
                       "Instance should implement EntityReference for iteration " + iteration);

            var entityRef = (EntityReference) instance;
            var mapping = extractOrdinalMapping(entityRef);

            ordinalMappings.add(mapping);
        }

        // Verify all mappings are identical
        var firstMapping = ordinalMappings.get(0);
        assertFalse(firstMapping.isEmpty(), "First mapping should not be empty");

        for (int i = 1; i < ordinalMappings.size(); i++) {
            var currentMapping = ordinalMappings.get(i);
            assertEquals(firstMapping.size(), currentMapping.size(),
                        "Mapping size should be consistent across iterations (iteration " + i + ")");

            for (var entry : firstMapping.entrySet()) {
                var ordinal = entry.getKey();
                var expectedSignature = entry.getValue();
                var actualSignature = currentMapping.get(ordinal);

                assertEquals(expectedSignature, actualSignature,
                            "Ordinal " + ordinal + " should map to the same method signature " +
                            "across all iterations (iteration " + i + ")");
            }
        }

        // Verify expected methods are present with sequential ordinals based on alphabetical ordering
        // Ordinals are stable and sequential (0, 1, 2, ...) based on method name + descriptor sort
        var ordinals = new ArrayList<>(firstMapping.keySet());
        ordinals.sort(Integer::compareTo);
        assertEquals(3, ordinals.size(), "MyTest should have exactly 3 event methods");

        // Verify ordinals are sequential starting from 0
        assertEquals(0, ordinals.get(0), "First ordinal should be 0");
        assertEquals(1, ordinals.get(1), "Second ordinal should be 1");
        assertEquals(2, ordinals.get(2), "Third ordinal should be 2");

        // Verify all methods are present somewhere in the mapping
        boolean hasBar = firstMapping.values().stream().anyMatch(sig -> sig.contains("bar()"));
        boolean hasMyMy = firstMapping.values().stream().anyMatch(sig -> sig.contains("myMy"));
        boolean hasSomeArgs = firstMapping.values().stream().anyMatch(sig -> sig.contains("someArgs"));

        assertTrue(hasBar, "bar() method should be present in ordinal mapping");
        assertTrue(hasMyMy, "myMy() method should be present in ordinal mapping");
        assertTrue(hasSomeArgs, "someArgs() method should be present in ordinal mapping");
    }

    /**
     * Extract ordinal-to-signature mapping from an EntityReference instance.
     * Queries __signatureFor for ordinals 0..99 until we get null responses.
     */
    private Map<Integer, String> extractOrdinalMapping(EntityReference entityRef) {
        var mapping = new HashMap<Integer, String>();

        // Query ordinals until we get nulls (indicating no more methods)
        for (int ordinal = 0; ordinal < 100; ordinal++) {
            try {
                var signature = entityRef.__signatureFor(ordinal);
                if (signature == null || signature.isEmpty()) {
                    break;
                }
                mapping.put(ordinal, signature);
            } catch (Exception e) {
                // Stop when we hit an unknown ordinal
                break;
            }
        }

        return mapping;
    }

    /**
     * Test that sequential ordinals are deterministic based on alphabetical ordering.
     * This verifies that ordinal assignment is based on sorted method order, not hash values.
     */
    @Test
    public void testSequentialOrdinalsDeterministic() throws Exception {
        var scanner = new ClassScanner()
            .addClasspathEntry(Path.of("target/test-classes"))
            .addClasspathEntry(Path.of("target/classes"))
            .scan();

        final var className = "com.hellblazer.primeMover.classfile.testClasses.MyTest";
        var transform = new SimulationTransform(scanner);
        var generator = transform.generatorOf(className);
        assertNotNull(generator);

        byte[] bytes = generator.generate();
        var loader = new ClassLoader(getClass().getClassLoader()) {
            {
                defineClass(className, ByteBuffer.wrap(bytes), null);
            }
        };
        var clazz = loader.loadClass(className);
        var instance = clazz.getConstructor().newInstance();
        var entityRef = (EntityReference) instance;

        // MyTest has methods: bar()V, myMy()Ljava/lang/String;, someArgs(Ljava/lang/String;Ljava/lang/Object;)[Ljava/lang/String;
        // Alphabetically sorted: bar, myMy, someArgs
        // Expected ordinals: 0, 1, 2
        var sig0 = entityRef.__signatureFor(0);
        var sig1 = entityRef.__signatureFor(1);
        var sig2 = entityRef.__signatureFor(2);

        assertTrue(sig0.contains("bar"), "Ordinal 0 should be bar() (alphabetically first)");
        assertTrue(sig1.contains("myMy"), "Ordinal 1 should be myMy() (alphabetically second)");
        assertTrue(sig2.contains("someArgs"), "Ordinal 2 should be someArgs() (alphabetically third)");
    }

    /**
     * Test that ordinals remain stable when the same generator instance is used multiple times.
     * This is a simpler test that verifies consistency within a single EntityGenerator instance.
     */
    @Test
    public void testOrdinalStabilityWithinSingleGenerator() throws Exception {
        var scanner = new ClassScanner()
            .addClasspathEntry(Path.of("target/test-classes"))
            .addClasspathEntry(Path.of("target/classes"))
            .scan();

        final var className = "com.hellblazer.primeMover.classfile.testClasses.MyTest";
        var transform = new SimulationTransform(scanner);
        var generator = transform.generatorOf(className);
        assertNotNull(generator);

        // Generate the same class multiple times from the same generator
        List<Map<Integer, String>> mappings = new ArrayList<>();

        for (int i = 0; i < 5; i++) {
            byte[] bytes = generator.generate();
            final int iteration = i;
            var loader = new ClassLoader(getClass().getClassLoader()) {
                {
                    defineClass(className, ByteBuffer.wrap(bytes), null);
                }
            };
            var clazz = loader.loadClass(className);
            var instance = clazz.getConstructor().newInstance();
            var entityRef = (EntityReference) instance;
            mappings.add(extractOrdinalMapping(entityRef));
        }

        // All mappings should be identical
        var firstMapping = mappings.get(0);
        for (int i = 1; i < mappings.size(); i++) {
            assertEquals(firstMapping, mappings.get(i),
                        "Mapping should be consistent across multiple generate() calls (iteration " + i + ")");
        }
    }
}
