package com.hellblazer.primeMover.asm;

import com.hellblazer.primeMover.api.Kronos;
import com.hellblazer.primeMover.classfile.EntityGenerator;
import com.hellblazer.primeMover.classfile.SimulationTransform;
import io.github.classgraph.ClassGraph;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test suite for SimulationTransform to ensure it produces structurally equivalent results to both the original
 * SimulationTransformOriginal and SimulationTransformRefactored implementations.
 */
public class SimulationTransformTest {

    private SimulationTransformOriginal   originalTransform;
    private SimulationTransformRefactored refactoredTransform;
    private SimulationTransform           classFileTransform;

    @BeforeEach
    public void setUp() {
        var classGraph = new ClassGraph().acceptPackages("com.hellblazer.primeMover.asm.testClasses",
                                                         "com.hellblazer.primeMover.api");
        originalTransform = new SimulationTransformOriginal(classGraph);
        refactoredTransform = new SimulationTransformRefactored(classGraph);
        classFileTransform = new SimulationTransform(classGraph);
    }

    @AfterEach
    public void tearDown() throws Exception {
        if (originalTransform != null) {
            originalTransform.close();
        }
        if (refactoredTransform != null) {
            refactoredTransform.close();
        }
        if (classFileTransform != null) {
            classFileTransform.close();
        }
    }

    @Test
    public void testApiRemappingEquivalence() {
        // Test that API remapping (Kronos -> Kairos) works equivalently
        var originalTransformed = originalTransform.transformed();
        var refactoredTransformed = refactoredTransform.transformed();
        var classFileTransformed = classFileTransform.transformed();

        // Find classes that should have API remapping
        originalTransformed.forEach((classInfo, originalBytecode) -> {
            var refactoredBytecode = refactoredTransformed.get(classInfo);
            var classFileBytecode = classFileTransformed.get(classInfo);

            if (refactoredBytecode != null && classFileBytecode != null) {
                // Check that all three handle API remapping consistently
                boolean originalHasKronos = containsKronosReference(originalBytecode);
                boolean refactoredHasKronos = containsKronosReference(refactoredBytecode);
                boolean classFileHasKronos = containsKronosReference(classFileBytecode);

                // All should have consistent Kronos/Kairos references
                assertEquals(refactoredHasKronos, classFileHasKronos,
                             "API remapping should be consistent for " + classInfo.getName());
            }
        });
    }

    @Test
    public void testClassFileTransformFunctionality() throws Exception {
        // Test that ClassFile API transform provides all expected functionality
        final var className = "com.hellblazer.primeMover.asm.testClasses.MyTest";

        // Test generatorOf
        var generator = classFileTransform.generatorOf(className);
        assertNotNull(generator, "Should create generator for known entity class");

        // Test generators
        var generators = classFileTransform.generators();
        assertTrue(generators.size() > 0, "Should find entity classes");

        // Test transformed
        var transformed = classFileTransform.transformed();
        assertTrue(transformed.size() > 0, "Should transform classes");

        // Test that generated bytecode is valid
        byte[] bytecode = generator.generate();
        assertTrue(bytecode.length > 0, "Should generate non-empty bytecode");

        // Test that bytecode is valid by parsing it
        ClassReader reader = new ClassReader(bytecode);
        ClassNode classNode = new ClassNode();
        reader.accept(classNode, 0);

        assertEquals(className.replace('.', '/'), classNode.name, "Generated class should have correct name");
        assertTrue(classNode.methods.size() > 0, "Generated class should have methods");
    }

    @Test
    public void testEntityInterfacesExtraction() {
        // Test the static utility method across all implementations
        var generators = originalTransform.generators();

        generators.keySet().forEach(classInfo -> {
            var originalInterfaces = SimulationTransformOriginal.getEntityInterfaces(classInfo);
            var refactoredInterfaces = SimulationTransformRefactored.getEntityInterfaces(classInfo);
            var classFileInterfaces = SimulationTransform.getEntityInterfaces(classInfo);

            assertEquals(originalInterfaces.size(), refactoredInterfaces.size(),
                         "Original and refactored should extract same number of entity interfaces for "
                         + classInfo.getName());
            assertEquals(refactoredInterfaces.size(), classFileInterfaces.size(),
                         "Refactored and ClassFile API should extract same number of entity interfaces for "
                         + classInfo.getName());

            var originalNames = originalInterfaces.stream().map(ci -> ci.getName()).collect(Collectors.toSet());
            var refactoredNames = refactoredInterfaces.stream().map(ci -> ci.getName()).collect(Collectors.toSet());
            var classFileNames = classFileInterfaces.stream().map(ci -> ci.getName()).collect(Collectors.toSet());

            assertEquals(originalNames, refactoredNames,
                         "Original and refactored should extract same entity interfaces for " + classInfo.getName());
            assertEquals(refactoredNames, classFileNames,
                         "Refactored and ClassFile API should extract same entity interfaces for "
                         + classInfo.getName());
        });
    }

    @Test
    public void testGeneratorOfStructuralEquivalence() throws Exception {
        final var className = "com.hellblazer.primeMover.asm.testClasses.MyTest";

        // Generate using original transform
        EntityGeneratorOriginal originalGenerator = originalTransform.generatorOf(className);
        assertNotNull(originalGenerator, "Original generator should not be null");
        byte[] originalBytecode = originalGenerator.generate().toByteArray();

        // Generate using refactored transform
        EntityGeneratorRefactored refactoredGenerator = refactoredTransform.generatorOf(className);
        assertNotNull(refactoredGenerator, "Refactored generator should not be null");
        byte[] refactoredBytecode = refactoredGenerator.generate().toByteArray();

        // Generate using ClassFile API transform
        EntityGenerator classFileGenerator = classFileTransform.generatorOf(className);
        assertNotNull(classFileGenerator, "ClassFile API generator should not be null");
        byte[] classFileBytecode = classFileGenerator.generate();

        // Compare structural equivalence
        assertStructuralEquivalence(originalBytecode, refactoredBytecode, className, "Original vs Refactored");
        assertStructuralEquivalence(refactoredBytecode, classFileBytecode, className, "Refactored vs ClassFile API");
        assertStructuralEquivalence(originalBytecode, classFileBytecode, className, "Original vs ClassFile API");
    }

    @Test
    public void testGeneratorsStructuralEquivalence() throws Exception {
        // Get generators from all transforms
        var originalGenerators = originalTransform.generators();
        var refactoredGenerators = refactoredTransform.generators();
        var classFileGenerators = classFileTransform.generators();

        // Should have same number of generators
        assertEquals(originalGenerators.size(), refactoredGenerators.size(),
                     "Original and refactored should have same number of entity generators");
        assertEquals(refactoredGenerators.size(), classFileGenerators.size(),
                     "Refactored and ClassFile API should have same number of entity generators");

        // Compare each entity across all three implementations
        originalGenerators.forEach((classInfo, originalGenerator) -> {
            var refactoredGenerator = refactoredGenerators.entrySet()
                                                          .stream()
                                                          .filter(
                                                          entry -> entry.getKey().getName().equals(classInfo.getName()))
                                                          .map(entry -> entry.getValue())
                                                          .findFirst()
                                                          .orElse(null);

            var classFileGenerator = classFileGenerators.entrySet()
                                                        .stream()
                                                        .filter(
                                                        entry -> entry.getKey().getName().equals(classInfo.getName()))
                                                        .map(entry -> entry.getValue())
                                                        .findFirst()
                                                        .orElse(null);

            assertNotNull(refactoredGenerator, "Should have refactored generator for " + classInfo.getName());
            assertNotNull(classFileGenerator, "Should have ClassFile API generator for " + classInfo.getName());

            try {
                byte[] originalBytecode = originalGenerator.generate().toByteArray();
                byte[] refactoredBytecode = refactoredGenerator.generate().toByteArray();
                byte[] classFileBytecode = classFileGenerator.generate();

                assertStructuralEquivalence(originalBytecode, refactoredBytecode, classInfo.getName(),
                                            "Original vs Refactored");
                assertStructuralEquivalence(refactoredBytecode, classFileBytecode, classInfo.getName(),
                                            "Refactored vs ClassFile API");
                assertStructuralEquivalence(originalBytecode, classFileBytecode, classInfo.getName(),
                                            "Original vs ClassFile API");
            } catch (Exception e) {
                throw new RuntimeException("Failed to generate bytecode for " + classInfo.getName(), e);
            }
        });
    }

    @Test
    public void testTimestampConsistency() throws Exception {
        // Test that setting timestamp produces consistent results
        final var className = "com.hellblazer.primeMover.asm.testClasses.MyTest";
        final var fixedTimestamp = "2025-05-25T01:00:00.000000Z";

        // Set same timestamp for all transforms
        refactoredTransform.setTransformTimestamp(fixedTimestamp);
        classFileTransform.setTransformTimestamp(fixedTimestamp);

        // Generate with refactored
        var refactoredGenerator = refactoredTransform.generatorOf(className);
        byte[] refactoredBytecode = refactoredGenerator.generate().toByteArray();

        // Generate with ClassFile API
        var classFileGenerator = classFileTransform.generatorOf(className);
        byte[] classFileBytecode = classFileGenerator.generate();

        // Should be structurally equivalent
        assertStructuralEquivalence(refactoredBytecode, classFileBytecode, className, "Timestamp consistency check");
    }

    @Test
    public void testTransformedClassesEquivalence() {
        // Get transformed classes from all transforms
        var originalTransformed = originalTransform.transformed();
        var refactoredTransformed = refactoredTransform.transformed();
        var classFileTransformed = classFileTransform.transformed();

        // Should have same number of transformed classes
        assertEquals(originalTransformed.size(), refactoredTransformed.size(),
                     "Original and refactored should have same number of transformed classes");
        assertEquals(refactoredTransformed.size(), classFileTransformed.size(),
                     "Refactored and ClassFile API should have same number of transformed classes");

        // Compare each transformed class across all three implementations
        originalTransformed.forEach((classInfo, originalBytecode) -> {
            var refactoredBytecode = refactoredTransformed.entrySet()
                                                          .stream()
                                                          .filter(
                                                          entry -> entry.getKey().getName().equals(classInfo.getName()))
                                                          .map(entry -> entry.getValue())
                                                          .findFirst()
                                                          .orElse(null);

            var classFileBytecode = classFileTransformed.entrySet()
                                                        .stream()
                                                        .filter(
                                                        entry -> entry.getKey().getName().equals(classInfo.getName()))
                                                        .map(entry -> entry.getValue())
                                                        .findFirst()
                                                        .orElse(null);

            assertNotNull(refactoredBytecode, "Should have refactored bytecode for " + classInfo.getName());
            assertNotNull(classFileBytecode, "Should have ClassFile API bytecode for " + classInfo.getName());

            try {
                assertStructuralEquivalence(originalBytecode, refactoredBytecode, classInfo.getName(),
                                            "Original vs Refactored");
                assertStructuralEquivalence(refactoredBytecode, classFileBytecode, classInfo.getName(),
                                            "Refactored vs ClassFile API");
                assertStructuralEquivalence(originalBytecode, classFileBytecode, classInfo.getName(),
                                            "Original vs ClassFile API");
            } catch (Exception e) {
                throw new RuntimeException("Failed to compare transformed class " + classInfo.getName(), e);
            }
        });
    }

    /**
     * Asserts that two bytecode arrays are structurally equivalent (same class structure, methods, interfaces) even if
     * not byte-identical.
     */
    private void assertStructuralEquivalence(byte[] bytecode1, byte[] bytecode2, String className, String comparison) {
        // Parse both bytecode arrays
        ClassReader reader1 = new ClassReader(bytecode1);
        ClassNode class1 = new ClassNode();
        reader1.accept(class1, 0);

        ClassReader reader2 = new ClassReader(bytecode2);
        ClassNode class2 = new ClassNode();
        reader2.accept(class2, 0);

        // Compare structural elements
        assertEquals(class1.name, class2.name, comparison + ": Class names should match for " + className);
        assertEquals(class1.superName, class2.superName,
                     comparison + ": Super class names should match for " + className);
        assertEquals(class1.interfaces, class2.interfaces, comparison + ": Interfaces should match for " + className);
        assertEquals(class1.fields.size(), class2.fields.size(),
                     comparison + ": Field count should match for " + className);
        assertEquals(class1.methods.size(), class2.methods.size(),
                     comparison + ": Method count should match for " + className);

        // Compare method signatures - handle Template class specially due to method ordering differences
        if (className.contains("Template")) {
            // For Template class, compare method sets rather than ordered lists
            var methods1Set = class1.methods.stream().map(m -> m.name + m.desc + m.access).collect(Collectors.toSet());
            var methods2Set = class2.methods.stream().map(m -> m.name + m.desc + m.access).collect(Collectors.toSet());
            assertEquals(methods1Set, methods2Set, comparison + ": Method sets should match for " + className);
        } else {
            // For other classes, maintain strict ordering
            for (int i = 0; i < class1.methods.size(); i++) {
                MethodNode method1 = class1.methods.get(i);
                MethodNode method2 = class2.methods.get(i);

                assertEquals(method1.name, method2.name,
                             comparison + ": Method name should match at index " + i + " for " + className);
                assertEquals(method1.desc, method2.desc,
                             comparison + ": Method descriptor should match for method " + method1.name + " in "
                             + className);
                assertEquals(method1.access, method2.access,
                             comparison + ": Method access flags should match for method " + method1.name + " in "
                             + className);
            }
        }
    }

    /**
     * Checks if bytecode contains references to Kronos (indicating it hasn't been remapped).
     *
     * @param bytecode The bytecode to check
     * @return true if Kronos references are found
     */
    private boolean containsKronosReference(byte[] bytecode) {
        ClassReader reader = new ClassReader(bytecode);
        ClassNode classNode = new ClassNode();
        reader.accept(classNode, 0);

        // Check constant pool for Kronos references
        try {
            String bytecodeString = new String(bytecode);
            return bytecodeString.contains("Kronos") || bytecodeString.contains(Kronos.class.getCanonicalName());
        } catch (Exception e) {
            return false;
        }
    }
}
